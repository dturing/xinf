#include <GL/gl.h>
#include <GL/glu.h>

/* ------------------------------------------------------------- */
/* simple GLU tesselator, outputs the tesselation using glVertex */
/* ------------------------------------------------------------- */

void simple_tess_begin( GLenum prim ) {
    glBegin( prim );
}

void simple_tess_vertex( void *_data ) {
    GLdouble* data = (GLdouble*)_data;
    glVertex3dv( data );
}

void simple_tess_end() {
    glEnd();
}

void simple_tess_combine( GLdouble c[3], void *d[4], GLfloat w[4], void **out ) {
    GLdouble *nv = (GLdouble*)malloc(sizeof(GLdouble)*3);
    nv[0] = c[0];
    nv[1] = c[1];
    nv[2] = c[2];
    *out = nv;
}

GLUtesselator *_gluSimpleTesselator( void ) {
    GLUtesselator *tess = gluNewTess();
    gluTessCallback( tess, GLU_TESS_BEGIN, (_GLUfuncptr)simple_tess_begin );
    gluTessCallback( tess, GLU_TESS_VERTEX, (_GLUfuncptr)simple_tess_vertex );
    gluTessCallback( tess, GLU_TESS_END, (_GLUfuncptr)simple_tess_end );
    gluTessCallback( tess, GLU_TESS_COMBINE, (_GLUfuncptr)simple_tess_combine );
    return tess;
}


void _gluTessCubicCurve( GLUtesselator *tess, value _ctrl, double *v, int _n ) {
    unsigned int i;
    int n = _n-1;
    
    // FIXME: check array
    
    value *ctrl = val_array_ptr( _ctrl );
	float controlPoints[4][2] = {
            { val_number( ctrl[0] ), val_number( ctrl[1] ) },
            { val_number( ctrl[2] ), val_number( ctrl[3] ) },
            { val_number( ctrl[4] ), val_number( ctrl[5] ) },
            { val_number( ctrl[6] ), val_number( ctrl[7] ) }
		};

    float bezierValues[3][2];
    float stepsize = 1.0/n;

	for( i = 0; i <= n; i++) {
        float t = ((float)i) * stepsize;
        float t1 = (1.0f - t);

        double *_v = &v[(i*3)];
        
        bezierValues[0][0] = t1 * controlPoints[0][0] + t * controlPoints[1][0];
        bezierValues[0][1] = t1 * controlPoints[0][1] + t * controlPoints[1][1];
    
        bezierValues[1][0] = t1 * controlPoints[1][0] + t * controlPoints[2][0];
        bezierValues[1][1] = t1 * controlPoints[1][1] + t * controlPoints[2][1];
        
        bezierValues[2][0] = t1 * controlPoints[2][0] + t * controlPoints[3][0];
        bezierValues[2][1] = t1 * controlPoints[2][1] + t * controlPoints[3][1];
        
        bezierValues[0][0] = t1 * bezierValues[0][0] + t * bezierValues[1][0];
        bezierValues[0][1] = t1 * bezierValues[0][1] + t * bezierValues[1][1];
    
        bezierValues[1][0] = t1 * bezierValues[1][0] + t * bezierValues[2][0];
        bezierValues[1][1] = t1 * bezierValues[1][1] + t * bezierValues[2][1];
        
        bezierValues[0][0] = t1 * bezierValues[0][0] + t * bezierValues[1][0];
        bezierValues[0][1] = t1 * bezierValues[0][1] + t * bezierValues[1][1];
        _v[0] = bezierValues[0][0];
        _v[1] = bezierValues[0][1];
        _v[2] = .0;
        
        gluTessVertex( tess, _v, (void*)_v );
    }	
}

void _gluTessQuadraticCurve( GLUtesselator *tess, value _ctrl, double *v, int _n ) {
    unsigned int i;
    int n = _n-1;
    
    // FIXME: check array
    
    value *ctrl = val_array_ptr( _ctrl );
	float controlPoints[3][2] = {
            { val_number( ctrl[0] ), val_number( ctrl[1] ) },
            { val_number( ctrl[2] ), val_number( ctrl[3] ) },
            { val_number( ctrl[4] ), val_number( ctrl[5] ) }
		};

    float bezierValues[2][2];
    float stepsize = 1.0/n;

	for( i = 0; i <= n; i++) {
        float t = ((float)i) * stepsize;
        float t1 = (1.0f - t);

        double *_v = &v[(i*3)];
        
        bezierValues[0][0] = t1 * controlPoints[0][0] + t * controlPoints[1][0];
        bezierValues[0][1] = t1 * controlPoints[0][1] + t * controlPoints[1][1];
    
        bezierValues[1][0] = t1 * controlPoints[1][0] + t * controlPoints[2][0];
        bezierValues[1][1] = t1 * controlPoints[1][1] + t * controlPoints[2][1];
        
        bezierValues[0][0] = t1 * bezierValues[0][0] + t * bezierValues[1][0];
        bezierValues[0][1] = t1 * bezierValues[0][1] + t * bezierValues[1][1];
    
        _v[0] = bezierValues[0][0];
        _v[1] = bezierValues[0][1];
        _v[2] = .0;
        
        gluTessVertex( tess, _v, (void*)_v );
    }	
}
