/***********************************************************************

   xinf is not flash.
   Copyright (c) 2006, Daniel Fischer.
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
																			
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU		
   Lesser General Public License or the LICENSE file for more details.
   
***********************************************************************/

#include "cptr.h"
#include <X11/Xlib.h>
#include <X11/extensions/Xdamage.h>
#include <fcntl.h>
#include <X11/XWDFile.h>
#include <unistd.h>
#include <sys/mman.h>
#include <GL/gl.h>

void ft_failure_2s( const char *one, const char *two ) {
    buffer b = alloc_buffer(one);
    buffer_append(b,two);
    val_throw(buffer_to_string(b));
}

void ft_failure_v( const char *one, value v ) {
    buffer b = alloc_buffer(one);
    val_buffer(b,v);
    val_throw(buffer_to_string(b));
}

value XIsValid( Display *dpy ) {
    if( !dpy ) return val_false;
    return val_true;
}

Drawable XRootAsDrawable( Display *dpy, int screen ) {
    return( RootWindow( dpy, screen ) );
}

XEvent *XNextEventVolatile( Display *display ) {
    static XEvent xev;
    XNextEvent( display, &xev );
    return &xev;
}

const unsigned int *XGetImageRGBA( Display *display, value pos, value sz, int alpha, int screen ) {
    field f_x = val_id("x");
    field f_y = val_id("y");
    int x = val_number( val_field( pos, f_x ) );
    int y = val_number( val_field( pos, f_y ) );
    int width = val_number( val_field( sz, f_x ) );
    int height = val_number( val_field( sz, f_y ) );
    
    unsigned int size = width * height * 4;
	unsigned char *data = (unsigned char *)malloc( size );
	if( !data ) {
        return NULL;
    }

    XGrabServer(display);
    
    XImage *ximg = XGetImage( display, RootWindow( display, screen ),
                    x, y, width, height, -1, ZPixmap );
    XFlush( display );
    if( ximg == NULL ) return NULL;
    
    {
		unsigned char *p = data;
		int            x,y,br,bg,bb,mg,mb,mr,lr,lg,lb;
		unsigned long  xpixel;
		switch( DefaultDepth( display, screen ) ) {
			case 15:
				br = 7; bg = 2; bb = 3;
				mr = mg = mb = 0xf8;
				lr = lg = lb = 0;
				break;
			case 16:
				br = 8; bg = 3; lb = 3;
				bb = lr = lg = 0;
				mr = mb = 0xf8;
				mg = 0xfc;
				break;
			case 24:
			case 32:
				br = 16;  bg = 8; bb = 0;
				lr = lg = lb = 0;
				mr = mg = mb = 0xff;
				break;
			default:
                return NULL;
		}

		for (y = 0; y < height; y++) {
			for (x = 0; x < width; x++) {
				xpixel = XGetPixel(ximg, x, y);
				*p++ = (((xpixel >> br) << lr) & mr);	// r
				*p++ = (((xpixel >> bg) << lg) & mg);	// g
				*p++ = (((xpixel >> bb) << lb) & mb);	// b 
				*p++ = alpha;							// a
			}
		}
    }
    
    XUngrabServer(display);
    
    return (unsigned int*)data;
}

// XDamage Helpers /////////////////////////////////////////////////////////

XDamageNotifyEvent *XCastDamageEvent( XEvent *evt ) {
    return( (XDamageNotifyEvent*)evt );
}

value XHaveDamageExtension( Display* dpy ) {
    int damage_ev;
    int err;
	if (!XDamageQueryExtension (dpy, &damage_ev, &err)) {
        return val_false;
	}
    return val_true;
}


// XTest Helpers /////////////////////////////////////////////////////////

int xtest_ev;
value XHaveTestExtension( Display* dpy ) {
    int err;
    int error_base, major, minor;
	if (!XTestQueryExtension (dpy, &xtest_ev, &error_base, &major, &minor )) {
        return val_false;
	}
    return val_true;
}

// Xvfb Helpers /////////////////////////////////////////////////////////

value XvfbOpen( Display *display, int screen, const char *file ) {
    int fb = open( file, O_RDONLY );
    if( fb == -1 ) return val_null;
    
    value r = alloc_object(NULL);
    alloc_field( r, val_id("_filehandle"), ALLOC_Int(fb) );
    
	int screen_width = DisplayWidth( display, screen );
	int screen_height = DisplayHeight( display, screen );
    int bpp = 4; // FIXME

	int size = (screen_width * screen_height * bpp);

	/* start memory mapping */
	int map_size = sizeof( struct _xwd_file_header )
					+ (0xff * sizeof(XWDColor))
					+ (size);

	unsigned char *map = (unsigned char *)mmap( NULL, map_size, PROT_READ, MAP_SHARED, fb, 0 );
	if( map == MAP_FAILED ) {
		map = NULL;
		close( fb );
		return val_null;
	}

    struct _xwd_file_header *header;
    header = (struct _xwd_file_header *)map;
    map = map + ntohl(header->header_size) + (ntohl( header->ncolors) * sizeof(XWDColor));

    alloc_field( r, val_id("_buffer"), ALLOC_KIND(map,k_void_p) );
    
    alloc_field( r, val_id("width"), ALLOC_Int( screen_width ) );
    alloc_field( r, val_id("height"), ALLOC_Int( screen_height ) );
//    alloc_field( r, val_id("width"), ALLOC_Int( header->pixmap_width ) );
//    alloc_field( r, val_id("height"), ALLOC_Int( header->pixmap_height ) );
    
    return r;
}
