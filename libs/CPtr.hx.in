/*
    CPtr: Low-Level haXe access to C Pointers.
        
    do not modify "CPtr.hx", but "CPtr.hx.in".
    
    
    _alloc(sz) 
        returns a garbage-collected C pointer of the type and size specified.
        
    _set(p,i,v)             
        sets p[i] = v.
        
    _get(p,i)               
        gets p[i].
        
    _to_array(p,from,to)
        returns neko array of p[from..to].
        
    _from_array(p,from,values)
        sets p[from...] to (the neko array) values.
*/

#if test
class TestCPtr extends haxe.unit.TestCase {
    function testInt() {
        var n:Int = 1024;
        var ptr = CPtr.int_alloc(n);
        
        for( i in 0...n ) {
            CPtr.int_set(ptr,i,i*10);
        }
        for( i in 0...n ) {
            assertEquals( i*10, CPtr.int_get(ptr,i) );
        }
    }

    function testFloat() {
        var n:Int = 1024;
        var ptr = CPtr.float_alloc(n);
        
        for( i in 0...n ) {
            CPtr.float_set(ptr,i,i*10);
        }
        for( i in 0...n ) {
            assertEquals( i*10, CPtr.float_get(ptr,i) );
        }
    }

    function testDouble() {
        var n:Int = 1024;
        var ptr = CPtr.double_alloc(n);
        
        for( i in 0...n ) {
            CPtr.double_set(ptr,i,i*10);
        }
        for( i in 0...n ) {
            assertEquals( i*10, CPtr.double_get(ptr,i) );
        }
    }

    function testIntToArray() {
        var n:Int = 1024;
        var ptr:Dynamic = CPtr.int_alloc(n);
        var a:Array<Int>;
        
        for( i in 0...n ) {
            CPtr.int_set(ptr,i,i*10);
        }
        a = CPtr.int_to_array( ptr, 0, n );
        for( i in 0...n ) {
            assertEquals( i*10, a[i] );
        }
    }
    
    function testIntFromArray() {
        var n:Int = 1024;
        var ptr:Dynamic = CPtr.int_alloc(n);
        var a = new Array<Int>();
        
        for( i in 0...n ) {
            a[i] = i*10;
        }
        CPtr.int_from_array( ptr, 0, untyped a.__a );
        for( i in 0...n ) {
            assertEquals( i*10, CPtr.int_get(ptr,i) );
        }
    }
    
    function testMemleak() {
        var n:Int = 1024 * 1024;
        var ptr:Dynamic;
        var mem1:Int;
        
        var mem0:Int = CPtr.getTotalMemUsage();
        
        for( i in 0...100 ) {
            ptr = CPtr.float_alloc(n);
            ptr = CPtr.double_alloc(n);
            ptr = CPtr.int_alloc(n);
            ptr = CPtr.uint_alloc(n);
            ptr = null;
        }
        CPtr.util_gc_major();

        mem1 = CPtr.getTotalMemUsage();
        assertEquals( mem0, mem1 );
    }
    
    function testInvalidAssignment() {
        var ptr:Dynamic = CPtr.double_alloc(2);
        try {
            CPtr.float_set( ptr, 2, 1 );
        } catch( e:Dynamic ) {
            assertTrue( true );
            return;
        }
        assertTrue( false );
    }

    function testIndexOutOfBounds() {
        var ptr:Dynamic = CPtr.double_alloc(2);
        try {
            CPtr.double_set( ptr, 3, 1 );
        } catch( e:Dynamic ) {
            assertTrue( true );
            return;
        }
        try {
            CPtr.double_set( ptr, -1, 1 );
        } catch( e:Dynamic ) {
            assertTrue( true );
            return;
        }
        assertTrue( false );
    }
}

#end // test

class CPtr {
    public static var float_alloc      = neko.Lib.load("cptr","cptr_float_alloc",1);
    public static var float_set        = neko.Lib.load("cptr","cptr_float_set",3);
    public static var float_get        = neko.Lib.load("cptr","cptr_float_get",2);
    public static var float_to_array   = neko.Lib.load("cptr","cptr_float_to_array",3);
    public static var float_from_array = neko.Lib.load("cptr","cptr_float_from_array",3);

    public static var double_alloc      = neko.Lib.load("cptr","cptr_double_alloc",1);
    public static var double_set        = neko.Lib.load("cptr","cptr_double_set",3);
    public static var double_get        = neko.Lib.load("cptr","cptr_double_get",2);
    public static var double_to_array   = neko.Lib.load("cptr","cptr_double_to_array",3);
    public static var double_from_array = neko.Lib.load("cptr","cptr_double_from_array",3);

    public static var int_alloc      = neko.Lib.load("cptr","cptr_int_alloc",1);
    public static var int_set        = neko.Lib.load("cptr","cptr_int_set",3);
    public static var int_get        = neko.Lib.load("cptr","cptr_int_get",2);
    public static var int_to_array   = neko.Lib.load("cptr","cptr_int_to_array",3);
    public static var int_from_array = neko.Lib.load("cptr","cptr_int_from_array",3);

    public static var uint_alloc      = neko.Lib.load("cptr","cptr_unsigned_int_alloc",1);
    public static var uint_set        = neko.Lib.load("cptr","cptr_unsigned_int_set",3);
    public static var uint_get        = neko.Lib.load("cptr","cptr_unsigned_int_get",2);
    public static var uint_to_array   = neko.Lib.load("cptr","cptr_unsigned_int_to_array",3);
    public static var uint_from_array = neko.Lib.load("cptr","cptr_unsigned_int_from_array",3);
    
    public static var void_null = neko.Lib.load("cptr","cptr_void_null",0)();
//    public static var isValid = neko.Lib.load("cptr","cptr_is_valid",1);

    // FIXME: move to some util lib, along with the impl.
    /** returns the number of milliseconds since start of the Epoch,
        but as a simple integer - so it does not necessarily express a date,
        but can be used for profiling **/
    public static var util_msec = neko.Lib.load("cptr","util_msec",0);

    public static var util_getpid = neko.Lib.load("cptr","util_getpid",0);
    public static var util_gc_major = neko.Lib.load("cptr","util_gc_major",0);

    public static function getTotalMemUsage() :Int {
        var fname = "/proc/"+util_getpid()+"/statm";
        
        // linux reports a filesize of 0 for /proc/#/statm, so this is neccessary
        // (though it could be more beautiful maybe with neko.FileSytem?)
        neko.Sys.command("cp "+fname+" /tmp/neko-statm");
        var statm = neko.File.getContent( "/tmp/neko-statm" );
        neko.Sys.command("rm -f /tmp/neko-statm");
        
        var r = statm.split(" ");
        return( Std.parseInt( r[0] ) );
    }
    
    #if test
        public static function main() {
                var r = new haxe.unit.TestRunner();
                r.add( new TestCPtr() );
                r.run();
        }
    #end
}
