/*
    CPtr: Low-Level haXe access to C Pointers.
    
    BEWARE: playing with pointers is not for the faint of heart. there are little checks,
    so this interface helps you to shoot in your foot as good as you could with C.
    
    ALSO: do not modify "CPtr.hx", but "CPtr.hx.in".
    
    
    _alloc(sz) 
        returns a garbage-collected C pointer of the type and size specified.
        
    _set(p,i,v)             
        sets p[i] = v.
        
    _get(p,i)               
        gets p[i].
        
    _to_array(p,from,to)
        returns neko array of p[from..to].
        
    _from_array(p,from,values)
        sets p[from...] to (the neko array) values.
*/

class TestCPtr extends haxe.unit.TestCase {
    function testInt() {
        var n:Int = 1024;
        var ptr = CPtr.int_alloc(n);
        
        for( i in 0...n ) {
            CPtr.int_set(ptr,i,i*10);
        }
        for( i in 0...n ) {
            assertEquals( CPtr.int_get(ptr,i), i*10 );
        }
    }

    function testFloat() {
        var n:Int = 1024;
        var ptr = CPtr.float_alloc(n);
        
        for( i in 0...n ) {
            CPtr.float_set(ptr,i,i*10);
        }
        for( i in 0...n ) {
            assertEquals( CPtr.float_get(ptr,i), i*10 );
        }
    }

    function testDouble() {
        var n:Int = 1024;
        var ptr = CPtr.double_alloc(n);
        
        for( i in 0...n ) {
            CPtr.double_set(ptr,i,i*10);
        }
        for( i in 0...n ) {
            assertEquals( CPtr.double_get(ptr,i), i*10 );
        }
    }
    
    
    function testMemleak() {
        var n:Int = 1024 * 1024;
        var ptr:Dynamic;
        var mem1:Int;
        
        var mem0:Int = CPtr.getTotalMemUsage();
        
        for( i in 0...100 ) {
            ptr = CPtr.float_alloc(n);
            ptr = CPtr.double_alloc(n);
            ptr = CPtr.int_alloc(n);
            ptr = CPtr.uint_alloc(n);
            ptr = null;
        }
        CPtr.util_gc_major();

        mem1 = CPtr.getTotalMemUsage();
        assertEquals( mem0, mem1 );
    }
}

class CPtr {
    public static var float_alloc      = neko.Lib.load("cptr","cptr_float_alloc",1);
    public static var float_set        = neko.Lib.load("cptr","cptr_float_set",3);
    public static var float_get        = neko.Lib.load("cptr","cptr_float_get",2);
//    public static var float_to_array   = neko.Lib.load("cptr","cptr_float_to_array",3);
//    public static var float_from_array = neko.Lib.load("cptr","cptr_float_from_array",3);

    public static var double_alloc      = neko.Lib.load("cptr","cptr_double_alloc",1);
    public static var double_set        = neko.Lib.load("cptr","cptr_double_set",3);
    public static var double_get        = neko.Lib.load("cptr","cptr_double_get",2);
//    public static var double_to_array   = neko.Lib.load("cptr","cptr_double_to_array",3);
//    public static var double_from_array = neko.Lib.load("cptr","cptr_double_from_array",3);

    public static var int_alloc      = neko.Lib.load("cptr","cptr_int_alloc",1);
    public static var int_set        = neko.Lib.load("cptr","cptr_int_set",3);
    public static var int_get        = neko.Lib.load("cptr","cptr_int_get",2);
//    public static var int_to_array   = neko.Lib.load("cptr","cptr_int_to_array",3);
//    public static var int_from_array = neko.Lib.load("cptr","cptr_int_from_array",3);

    public static var uint_alloc      = neko.Lib.load("cptr","cptr_unsigned_int_alloc",1);
    public static var uint_set        = neko.Lib.load("cptr","cptr_unsigned_int_set",3);
    public static var uint_get        = neko.Lib.load("cptr","cptr_unsigned_int_get",2);
//    public static var uint_to_array   = neko.Lib.load("cptr","cptr_unsigned_int_to_array",3);
//    public static var uint_from_array = neko.Lib.load("cptr","cptr_unsigned_int_from_array",3);
    
    public static var void_null = neko.Lib.load("cptr","cptr_void_null",0)();
//    public static var isValid = neko.Lib.load("cptr","cptr_is_valid",1);

    // FIXME: move to some util lib, along with the impl.
    /** returns the number of milliseconds since start of the Epoch,
        but as a simple integer - so it does not necessarily express a date,
        but can be used for profiling **/
    public static var util_msec = neko.Lib.load("cptr","util_msec",0);

    public static var util_getpid = neko.Lib.load("cptr","util_getpid",0);
    public static var util_gc_major = neko.Lib.load("cptr","util_gc_major",0);

    public static function getTotalMemUsage() :Int {
        var fname = "/proc/"+util_getpid()+"/statm";
        
        // linux reports a filesize of 0 for /proc/#/statm, so this is neccessary
        // (though it could be more beautiful maybe with neko.FileSytem?)
        neko.Sys.command("cp "+fname+" /tmp/neko-statm");
        var statm = neko.File.getContent( "/tmp/neko-statm" );
        neko.Sys.command("rm -f /tmp/neko-statm");
        
        var r = statm.split(" ");
        return( Std.parseInt( r[0] ) );
    }
    
    public static function main() {
        var r = new haxe.unit.TestRunner();
        r.add( new TestCPtr() );
        r.run();
/*
            trace("alloc");
            CPtr.double_alloc(100);
            trace("trigger gc");
            CPtr.util_gc_major();
            trace("GC should happen before this!");
*/
    }
}
