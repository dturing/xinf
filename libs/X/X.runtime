/***********************************************************************

   xinf is not flash.
   Copyright (c) 2006, Daniel Fischer.
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
																			
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU		
   Lesser General Public License or the LICENSE file for more details.
   
***********************************************************************/

#include "cptr.h"
#include <X11/Xlib.h>
#include <X11/extensions/Xdamage.h>
#include <fcntl.h>
#include <X11/XWDFile.h>
#include <unistd.h>
#include <sys/mman.h>
#include <GL/gl.h>

value XIsValid( Display *dpy ) {
    if( !dpy ) return val_false;
    return val_true;
}

Drawable XRootAsDrawable( Display *dpy, int screen ) {
    return( RootWindow( dpy, screen ) );
}

XEvent *XNextEventVolatile( Display *display ) {
    static XEvent xev;
    XNextEvent( display, &xev );
    return &xev;
}

void XGetImageRGBA( value dpy, value pos, value sz, value data_sz, unsigned int *data ) {
    int _x, _y;

    field f_x = val_id("x");
    field f_y = val_id("y");

    Display *display = val_data( val_field( dpy, val_id("display") ) );
    int screen = val_number( val_field( dpy, val_id("screen") ) );
    
    int x = val_number( val_field( pos, f_x ) );
    int y = val_number( val_field( pos, f_y ) );
    int width = val_number( val_field( sz, f_x ) );
    int height = val_number( val_field( sz, f_y ) );
    int d_width = val_number( val_field( data_sz, f_x ) );
    int d_height = val_number( val_field( data_sz, f_y ) );
    
    unsigned int size = width * height * 4;

    XGrabServer(display);
    
    XImage *ximg = XGetImage( display, RootWindow( display, screen ),
                    x, y, width, height, -1, ZPixmap );
    XFlush( display );
    if( ximg == NULL ) return;
    
    {
		unsigned char *p;
		int            br,bg,bb,mg,mb,mr,lr,lg,lb;
		unsigned long  xpixel;
		switch( DefaultDepth( display, screen ) ) {
			case 15:
				br = 7; bg = 2; bb = 3;
				mr = mg = mb = 0xf8;
				lr = lg = lb = 0;
				break;
			case 16:
				br = 8; bg = 3; lb = 3;
				bb = lr = lg = 0;
				mr = mb = 0xf8;
				mg = 0xfc;
				break;
			case 24:
			case 32:
				br = 16;  bg = 8; bb = 0;
				lr = lg = lb = 0;
				mr = mg = mb = 0xff;
				break;
			default:
                return;
		}

		for (_y = 0; _y < height; _y++) {
            p = &data[ (x + ((_y+y)*d_width)) ];
			for (_x = 0; _x < width; _x++) {
				xpixel = XGetPixel(ximg, _x, _y);
				*p++ = (((xpixel >> br) << lr) & mr);	// r
				*p++ = (((xpixel >> bg) << lg) & mg);	// g
				*p++ = (((xpixel >> bb) << lb) & mb);	// b 
				*p++ = 0xff;							// a
			}
		}
    }
    
    XUngrabServer(display);
}

// XDamage Helpers /////////////////////////////////////////////////////////

XDamageNotifyEvent *XCastDamageEvent( XEvent *evt ) {
    return( (XDamageNotifyEvent*)evt );
}

value XHaveDamageExtension( Display* dpy ) {
    int damage_ev;
    int err;
	if (!XDamageQueryExtension (dpy, &damage_ev, &err)) {
        return val_false;
	}
    return val_true;
}


// XTest Helpers /////////////////////////////////////////////////////////

int xtest_ev;
value XHaveTestExtension( Display* dpy ) {
    int err;
    int error_base, major, minor;
	if (!XTestQueryExtension (dpy, &xtest_ev, &error_base, &major, &minor )) {
        return val_false;
	}
    return val_true;
}

// Xvfb Helpers /////////////////////////////////////////////////////////

value XvfbOpen( Display *display, int screen, const char *file ) {
    int fb = open( file, O_RDONLY );
    if( fb == -1 ) return val_null;
    
    value r = alloc_object(NULL);
    alloc_field( r, val_id("_filehandle"), ALLOC_Int(fb) );
    
	int screen_width = DisplayWidth( display, screen );
	int screen_height = DisplayHeight( display, screen );
    int bpp = 4; // FIXME

	int size = (screen_width * screen_height * bpp);

	/* start memory mapping */
	int map_size = sizeof( struct _xwd_file_header )
					+ (0xff * sizeof(XWDColor))
					+ (size);

	unsigned char *map = (unsigned char *)mmap( NULL, map_size, PROT_READ, MAP_SHARED, fb, 0 );
	if( map == MAP_FAILED ) {
		map = NULL;
		close( fb );
		return val_null;
	}

    struct _xwd_file_header *header;
    header = (struct _xwd_file_header *)map;
    map = map + ntohl(header->header_size) + (ntohl( header->ncolors) * sizeof(XWDColor));

    alloc_field( r, val_id("_buffer"), cptr_void_alloc(map,0) );
    
    alloc_field( r, val_id("width"), ALLOC_Int( screen_width ) );
    alloc_field( r, val_id("height"), ALLOC_Int( screen_height ) );
//    alloc_field( r, val_id("width"), ALLOC_Int( header->pixmap_width ) );
//    alloc_field( r, val_id("height"), ALLOC_Int( header->pixmap_height ) );
    
    return r;
}

value image_compare( const unsigned int *one, const unsigned int *two, int nPixels ) {
    float acc=.0;
    int i;
    
    const unsigned char *a = (const unsigned char *)one;
    const unsigned char *b = (const unsigned char *)two;
    nPixels *= 4;
    
    for( i=0; i<nPixels; i++ ) {
            acc += ((float)abs(a[i]-b[i]))/0xff;
    }
    return( alloc_float( acc/nPixels ) );
}
