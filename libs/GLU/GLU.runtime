/***********************************************************************

   xinf is not flash.
   Copyright (c) 2006, Daniel Fischer.
 
   This library is free software; you can redistribute it and/or
   modify it under the terms of the GNU Lesser General Public
   License as published by the Free Software Foundation; either
   version 2.1 of the License, or (at your option) any later version.
																			
   This library is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU		
   Lesser General Public License or the LICENSE file for more details.
   
***********************************************************************/

#include <GL/gl.h>
#include <GL/glu.h>

/* ------------------------------------------------------------- */
/* simple GLU tesselator, outputs the tesselation using glVertex */
/* ------------------------------------------------------------- */

void simple_tess_combine( GLdouble c[3], void *d[4], GLfloat w[4], void **out ) {
    GLdouble *nv = (GLdouble*)malloc(sizeof(GLdouble)*3);
    nv[0] = c[0];
    nv[1] = c[1];
    nv[2] = c[2];
    *out = nv;
}

void simple_tess_error( GLenum err ) {
    val_throw( alloc_string( "tesselation error" ) );
}

GLUtesselator *gluSimpleTesselator( void ) {
    GLUtesselator *tess = gluNewTess();
    gluTessCallback( tess, GLU_TESS_BEGIN, (_GLUfuncptr)glBegin );
    gluTessCallback( tess, GLU_TESS_VERTEX, (_GLUfuncptr)glVertex3dv );
    gluTessCallback( tess, GLU_TESS_END, (_GLUfuncptr)glEnd );
    gluTessCallback( tess, GLU_TESS_COMBINE, (_GLUfuncptr)simple_tess_combine );
    gluTessCallback( tess, GLU_TESS_ERROR, (_GLUfuncptr)simple_tess_error );
    return tess;
}

void gluTessVertexSimple( GLUtesselator *tess, double *v ) {
    gluTessVertex( tess, v, (void*)v );
}

void gluTessCubicCurve( GLUtesselator *tess, value _ctrl, double *v, int _n ) {
    unsigned int i;
    int n = _n-1;
    
    // FIXME: check array
    
    value *ctrl = val_array_ptr( _ctrl );
	float controlPoints[4][2] = {
            { val_number( ctrl[0] ), val_number( ctrl[1] ) },
            { val_number( ctrl[2] ), val_number( ctrl[3] ) },
            { val_number( ctrl[4] ), val_number( ctrl[5] ) },
            { val_number( ctrl[6] ), val_number( ctrl[7] ) }
		};

    float bezierValues[3][2];
    float stepsize = 1.0/n;

	for( i = 0; i <= n; i++) {
        float t = ((float)i) * stepsize;
        float t1 = (1.0f - t);

        double *_v = &v[(i*3)];
        
        bezierValues[0][0] = t1 * controlPoints[0][0] + t * controlPoints[1][0];
        bezierValues[0][1] = t1 * controlPoints[0][1] + t * controlPoints[1][1];
    
        bezierValues[1][0] = t1 * controlPoints[1][0] + t * controlPoints[2][0];
        bezierValues[1][1] = t1 * controlPoints[1][1] + t * controlPoints[2][1];
        
        bezierValues[2][0] = t1 * controlPoints[2][0] + t * controlPoints[3][0];
        bezierValues[2][1] = t1 * controlPoints[2][1] + t * controlPoints[3][1];
        
        bezierValues[0][0] = t1 * bezierValues[0][0] + t * bezierValues[1][0];
        bezierValues[0][1] = t1 * bezierValues[0][1] + t * bezierValues[1][1];
    
        bezierValues[1][0] = t1 * bezierValues[1][0] + t * bezierValues[2][0];
        bezierValues[1][1] = t1 * bezierValues[1][1] + t * bezierValues[2][1];
        
        bezierValues[0][0] = t1 * bezierValues[0][0] + t * bezierValues[1][0];
        bezierValues[0][1] = t1 * bezierValues[0][1] + t * bezierValues[1][1];
        _v[0] = bezierValues[0][0];
        _v[1] = bezierValues[0][1];
        _v[2] = .0;
        
        gluTessVertex( tess, _v, (void*)_v );
    }	
}

void gluTessQuadraticCurve( GLUtesselator *tess, value _ctrl, double *v, int _n ) {
    unsigned int i;
    int n = _n-1;
    
    // FIXME: check array
    
    value *ctrl = val_array_ptr( _ctrl );
	float controlPoints[3][2] = {
            { val_number( ctrl[0] ), val_number( ctrl[1] ) },
            { val_number( ctrl[2] ), val_number( ctrl[3] ) },
            { val_number( ctrl[4] ), val_number( ctrl[5] ) }
		};

    float bezierValues[2][2];
    float stepsize = 1.0/n;

	for( i = 0; i <= n; i++) {
        float t = ((float)i) * stepsize;
        float t1 = (1.0f - t);

        double *_v = &v[(i*3)];
        
        bezierValues[0][0] = t1 * controlPoints[0][0] + t * controlPoints[1][0];
        bezierValues[0][1] = t1 * controlPoints[0][1] + t * controlPoints[1][1];
    
        bezierValues[1][0] = t1 * controlPoints[1][0] + t * controlPoints[2][0];
        bezierValues[1][1] = t1 * controlPoints[1][1] + t * controlPoints[2][1];
        
        bezierValues[0][0] = t1 * bezierValues[0][0] + t * bezierValues[1][0];
        bezierValues[0][1] = t1 * bezierValues[0][1] + t * bezierValues[1][1];
    
        _v[0] = bezierValues[0][0];
        _v[1] = bezierValues[0][1];
        _v[2] = .0;
        
        gluTessVertex( tess, _v, (void*)_v );
    }	
}
